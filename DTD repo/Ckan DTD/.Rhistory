as.data.frame(stringsAsFactors = FALSE)
j <-1
header <- table %>%
html_nodes("thead th") %>%
html_text(trim = TRUE)
rows <- table %>%
html_nodes("tbody tr") %>%
lapply(function(row) {
html_nodes(row, "td") %>%
html_text(trim = TRUE)
}) %>%
do.call(rbind, .) %>%
as.data.frame(stringsAsFactors = FALSE)
rows
table
table <- tables[[j]]
table
# Extract the header
header <- table %>%
html_nodes("thead th") %>%
html_text(trim = TRUE)
header
html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
# Extract the rows
rows <- table %>%
html_nodes("tbody tr") %>%
lapply(function(row) {
html_nodes(row, "td") %>%
html_text(trim = TRUE)
}) %>%
do.call(rbind, .) %>%
as.data.frame(stringsAsFactors = FALSE)
rows
header
# Set the column names
colnames(rows) <- header
rows
ifelse(i <= length(table_headers), table_headers[i], NA)
attr(rows, "table_header") <- ifelse(i <= length(table_headers), table_headers[i], NA)
ifelse(i <= length(table_headers), table_headers[i], NA)
j <- 3
card <- cards[[i]]
card
# Extract table header
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
header_text
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
header_text
i <- 3
j <- 1
card <- cards[[i]]
# Extract table header
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
header_text
length(tables) > 0
# Extract tables within the card
tables <- html_nodes(card, "table")
tables
length(tables) > 0
rm(i, j)
# Parse the HTML content
response <- read_html(response)
response <- content(GET(unlist(Declaraciones_Juradas_Funcionarios[ numb, ]$new_url)), "text")
# Parse the HTML content
response <- read_html(response)
# Extract cards
cards <- html_nodes(response, ".card")
# Extract table headers
table_headers <- html_nodes(response, "div.card-header strong") %>% html_text(trim = TRUE)
# Initialize list to store tables with attributes
list_of_tables <- list()
list_of_tables
rm(i, j)
# Iterate through cards and extract tables
for (i in seq_along(cards)) {
card <- cards[[i]]
# Extract table header
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
# Extract tables within the card
tables <- html_nodes(card, "table")
# Process only if there are tables
if (length(tables) > 0) {
# Process each table
for (j in seq_along(tables)) {
table <- tables[[j]]
# Extract the header
header <- table %>%
html_nodes("thead th") %>%
html_text(trim = TRUE)
# Extract the rows
rows <- table %>%
html_nodes("tbody tr") %>%
lapply(function(row) {
html_nodes(row, "td") %>%
html_text(trim = TRUE)
}) %>%
do.call(rbind, .) %>%
as.data.frame(stringsAsFactors = FALSE)
# Set the column names
colnames(rows) <- header
# Add the table header as an attribute, check if header_text exists in table_headers
attr(rows, "table_header") <- ifelse(i <= length(table_headers), table_headers[i], NA)
# Add to list_of_tables
list_of_tables[[length(list_of_tables) + 1]] <- rows
}
}
}
list_of_tables
ifelse(i <= length(table_headers), table_headers[i], NA)
attr(rows, "table_header")
View(list_of_tables[[1]])
list_of_tables[[i]]
i
Declaraciones_Juradas_Funcionarios$new_url[numb]
response <- content(GET(unlist(Declaraciones_Juradas_Funcionarios[ numb, ]$new_url)), "text")
# Parse the HTML content
response <- read_html(response)
# Extract cards
cards <- html_nodes(response, ".card")
# Extract table headers
table_headers <- html_nodes(response, "div.card-header strong") %>% html_text(trim = TRUE)
# Initialize list to store tables with attributes
list_of_tables <- list()
rm(i, j)
# Iterate through cards and extract tables
for (i in seq_along(cards)) {
card <- cards[[i]]
# Extract table header
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
# Extract tables within the card
tables <- html_nodes(card, "table")
# Process only if there are tables
if (length(tables) > 0) {
# Process each table
for (j in seq_along(tables)) {
table <- tables[[j]]
# Extract the header
header <- table %>%
html_nodes("thead th") %>%
html_text(trim = TRUE)
# Extract the rows
rows <- table %>%
html_nodes("tbody tr") %>%
lapply(function(row) {
html_nodes(row, "td") %>%
html_text(trim = TRUE)
}) %>%
do.call(rbind, .) %>%
as.data.frame(stringsAsFactors = FALSE)
# Set the column names
colnames(rows) <- header
# Add to list_of_tables
list_of_tables[[length(list_of_tables) + 1]] <- rows
# Add the table header as an attribute, check if header_text exists in table_headers
list_of_tables[[i]] <- list_of_tables[[i]] %>% dplyr::mutate(Tipo_informacion = table_headers[[i]])
}
}
}
list_of_tables[[i]]
i <- 1
card <- cards[[i]]
# Extract table header
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
# Extract tables within the card
tables <- html_nodes(card, "table")
header_text
# Extract tables within the card
tables <- html_nodes(card, "table")
tables
length(tables) > 0
table <- tables[[j]]
# Extract the header
header <- table %>%
html_nodes("thead th") %>%
html_text(trim = TRUE)
header
# Extract the rows
rows <- table %>%
html_nodes("tbody tr") %>%
lapply(function(row) {
html_nodes(row, "td") %>%
html_text(trim = TRUE)
}) %>%
do.call(rbind, .) %>%
as.data.frame(stringsAsFactors = FALSE)
rows
# Set the column names
colnames(rows) <- header
rows
rows %>% dplyr::mutate(Tipo_informacion = table_headers[[i]])
response <- content(GET(unlist(Declaraciones_Juradas_Funcionarios[ numb, ]$new_url)), "text")
# Parse the HTML content
response <- read_html(response)
# Extract cards
cards <- html_nodes(response, ".card")
# Extract table headers
table_headers <- html_nodes(response, "div.card-header strong") %>% html_text(trim = TRUE)
# Initialize list to store tables with attributes
list_of_tables <- list()
i <- 1
rm(i, j)
# Iterate through cards and extract tables
for (i in seq_along(cards)) {
card <- cards[[i]]
# Extract table header
header_text <- html_node(card, ".card-header strong") %>% html_text(trim = TRUE)
# Extract tables within the card
tables <- html_nodes(card, "table")
# Process only if there are tables
if (length(tables) > 0) {
# Process each table
for (j in seq_along(tables)) {
table <- tables[[j]]
# Extract the headers
header <- table %>%
html_nodes("thead th") %>%
html_text(trim = TRUE)
# Extract the rows
rows <- table %>%
html_nodes("tbody tr") %>%
lapply(function(row) {
html_nodes(row, "td") %>%
html_text(trim = TRUE)
}) %>%
do.call(rbind, .) %>%
as.data.frame(stringsAsFactors = FALSE)
# Set the column names
colnames(rows) <- header
# Add the table header as an attribute, check if header_text exists in table_headers
rows <- rows %>% dplyr::mutate(Tipo_informacion = table_headers[[i]])
# Add to list_of_tables
list_of_tables[[length(list_of_tables) + 1]] <- rows
}
}
}
# Create a new workbook
wb <- createWorkbook()
wb
rm(i)
# Iterate through the list of data frames and add each to a separate sheet
for (i in seq_along(list_of_tables)) {
sheet_name <- paste("Sheet", i, sep = "_")  # Generate sheet names like "Sheet_1", "Sheet_2", etc.
addWorksheet(wb, sheet_name)
writeData(wb, sheet = sheet_name, x = list_of_tables[[i]])
}
wb
rm(i)
sheet
list_of_tables[[i]]
i <- 1
list_of_tables[[i]]
table_headers[[i]]
sheet <- 1
list_of_tables[[sheet]]
unique(list_of_tables[[sheet]]$Tipo_informacion)
unique(list_of_tables[[sheet]]$Tipo_informacion)[1]
gsub(" ", "_", unique(list_of_tables[[sheet]]$Tipo_informacion)[1])
sheet
rm(sheet)
# Create a new workbook
wb <- createWorkbook()
# Iterate through the list of data frames and add each to a separate sheet
for (sheet in seq_along(list_of_tables)) {
sheet_name <- unique(list_of_tables[[sheet]]$Tipo_informacion)[1]  # Generate sheet names like "Sheet_1", "Sheet_2", etc.
addWorksheet(wb, sheet_name)
writeData(wb, sheet = sheet_name, x = list_of_tables[[i]])
}
rm(sheet)
# Create a new workbook
wb <- createWorkbook()
wb
sheet
seq_along(list_of_tables)
sheet <- 1
sheet_name <- paste("Sheet", i, sep = "_")  # Generate a generic sheet name
sheet_name
addWorksheet(wb, sheet_name)
wb
unique(list_of_tables[[sheet]]$Tipo_informacion)[1])
unique(list_of_tables[[sheet]]$Tipo_informacion)[1]
writeData(wb, sheet = sheet_name, x = unique(list_of_tables[[sheet]]$Tipo_informacion)[1], startCol = 1, startRow = 1, colNames = FALSE, rowNames = FALSE)
seq_along(list_of_tables)
writeData(wb, sheet = sheet_name, x = list_of_tables[[sheet]], startCol = 1, startRow = 2)
wb
saveWorkbook(wb, fil = "C:/Users/arysa/Downloads/output.xlsx", overwrite = TRUE)
unique(list_of_tables[[sheet]]$Tipo_informacion)[1]
table_headers
rm(numb)
1:nrow(Declaraciones_Juradas_Funcionarios)
rm(sheet)
numb <- 1
paste0(Declaraciones_Juradas_Funcionarios$Nombre)
paste0(Declaraciones_Juradas_Funcionarios$Nombre, Declaraciones_Juradas_Funcionarios$Apellido)
paste0(Declaraciones_Juradas_Funcionarios$Nombre, " ", Declaraciones_Juradas_Funcionarios$Apellido)
paste0(Declaraciones_Juradas_Funcionarios$Nombre, ", ", Declaraciones_Juradas_Funcionarios$Apellido)
paste0(Declaraciones_Juradas_Funcionarios$Nombre, ", ", Declaraciones_Juradas_Funcionarios$Apellido)[numb]
paste0("C:/Users/arysa/Downloads/", paste0(Declaraciones_Juradas_Funcionarios$Nombre, ", ", Declaraciones_Juradas_Funcionarios$Apellido)[numb], ".xlsx")
paste0("C:/Users/arysa/Downloads/", paste0(Declaraciones_Juradas_Funcionarios$Nombre, " ", Declaraciones_Juradas_Funcionarios$Apellido)[numb], ".xlsx")
nrow(Declaraciones_Juradas_Funcionarios
nrow(Declaraciones_Juradas_Funcionarios)
nrow(Declaraciones_Juradas_Funcionarios)
numb/nrow(Declaraciones_Juradas_Funcionarios)
print((numb/nrow(Declaraciones_Juradas_Funcionarios))*100)
print(paste0("Completado ", (numb/nrow(Declaraciones_Juradas_Funcionarios))*100))
print(paste0("Completado ", round(numb/nrow(Declaraciones_Juradas_Funcionarios))*100, 2))
print(paste0("Completado ", round((numb/nrow(Declaraciones_Juradas_Funcionarios))*100), 2))
(numb/nrow(Declaraciones_Juradas_Funcionarios))*100)
numb/nrow(Declaraciones_Juradas_Funcionarios))*100
(numb/nrow(Declaraciones_Juradas_Funcionarios))*100
print(paste0("Completado ", round(((numb/nrow(Declaraciones_Juradas_Funcionarios))*100), 2))
numb/nrow(Declaraciones_Juradas_Funcionarios
numb/nrow(Declaraciones_Juradas_Funcionarios
numb/nrow(Declaraciones_Juradas_Funcionarios)
numb/nrow(Declaraciones_Juradas_Funcionarios)
numb/nrow(Declaraciones_Juradas_Funcionarios)*100
print(paste0("Completado ", round(numb/nrow(Declaraciones_Juradas_Funcionarios)*100, 2))
print(paste0("Completado ", round(numb/nrow(Declaraciones_Juradas_Funcionarios)*100, 2))
numb/nrow(Declaraciones_Juradas_Funcionarios)*100
print(paste0("Completado ", round((numb/nrow(Declaraciones_Juradas_Funcionarios)*100), 2))
print(paste0("Completado ", round((numb/nrow(Declaraciones_Juradas_Funcionarios)*100), 2))
round((numb/nrow(Declaraciones_Juradas_Funcionarios)*100), 2)
print(paste0("Completado ", round((numb/nrow(Declaraciones_Juradas_Funcionarios)*100), 2), "%")
print(paste0("Completado ", round((numb/nrow(Declaraciones_Juradas_Funcionarios)*100), 2), "%"))
print(paste0("Completado ", round((numb/nrow(Declaraciones_Juradas_Funcionarios)*100), 2), "%"))
rm(i, j)
numb <- 1
library(rvest)
library(httr)
library(tidyr)
library(openxlsx)
page <- read_html("https://ciudaddemendoza.gob.ar/licitaciones-de-obras-publicas/") # Licitaciones de obra pública
# Function to clean and separate the text into 4 parts
clean_and_split <- function(text) {
# Replace multiple newlines and tabs with a single newline
text <- gsub("\n+", "\n", text)
text <- gsub("\t+", "", text)
# Split the text by newline
parts <- unlist(strsplit(text, "\n"))
# Trim whitespace and remove empty parts
parts <- trimws(parts)
parts <- parts[parts != ""]
return(parts)
}
# Initialize an empty list to store the elements
all_elements <- list()
# Loop over the range of XPaths
for (i in 4:290) {
xpath <- paste0('//*[@id="page_container"]/div[3]/div/div/div[1]/div/div/div[', i, ']')
element <- page %>% html_node(xpath = xpath) %>% html_text(trim = TRUE)
if (!is.null(element)) {
cleaned_element <- clean_and_split(element)
all_elements[[length(all_elements) + 1]] <- cleaned_element
}
}
# Convert the list to a dataframe
data_df <- do.call(rbind, all_elements) %>% as.data.frame(stringsAsFactors = FALSE)
data_df <- data_df %>% dplyr::mutate(V5 = ifelse(V5 == V1, NA, V5),
V6 = ifelse(V6 == V1 | V6 == V2, NA, V6))
View(data_df)
library(rvest)
library(httr)
library(tidyr)
library(openxlsx)
source("C:/Users/arysa/OneDrive/Github/DTD/Ckan DTD/Scrapper_licicontrataciones.R", echo=TRUE)
page <- read_html("https://ciudaddemendoza.gob.ar/licitaciones-de-obras-publicas/") # Licitaciones de obra pública
# Function to clean and separate the text into 4 parts
clean_and_split <- function(text) {
# Replace multiple newlines and tabs with a single newline
text <- gsub("\n+", "\n", text)
text <- gsub("\t+", "", text)
# Split the text by newline
parts <- unlist(strsplit(text, "\n"))
# Trim whitespace and remove empty parts
parts <- trimws(parts)
parts <- parts[parts != ""]
return(parts)
}
# Initialize an empty list to store the elements
all_elements <- list()
all_elements
seq(5,92,2)
seq(3,92,2)
seq(3,11,2)
seq(12,92,2)
c(seq(3,11,2), seq(12,92,2))
# Initialize an empty list to store the elements
all_elements <- list()
# Loop over the range of XPaths
for (
# i in 4:290 # licitaciones y contrataciones
i in c(seq(3,11,2), seq(12,92,2)) # licitaciones de obra pública
) {
# xpath <- paste0('//*[@id="page_container"]/div[3]/div/div/div[1]/div/div/div[', i, ']') # licitaciones y contrataciones
xpath <- paste0("//*[@id='page_container']/div[3]/div[1]/div/div[1]/div/div/div[3]/div/div/div/div[", i, "]") # Licitaciones de obra pública
element <- page %>% html_node(xpath = xpath) %>% html_text(trim = TRUE)
if (!is.null(element)) {
cleaned_element <- clean_and_split(element)
all_elements[[length(all_elements) + 1]] <- cleaned_element
}
}
View(all_elements)
c(seq(3,11,2),12,13,14 seq(16,92,2))
seq(3,11,2)
c(seq(3,11,2),12,13,14, seq(16,92,2))
# Initialize an empty list to store the elements
all_elements <- list()
# Loop over the range of XPaths
for (
# i in 4:290 # licitaciones y contrataciones
i in c(seq(3,11,2),12,13,14, seq(16,92,2)) # licitaciones de obra pública
) {
# xpath <- paste0('//*[@id="page_container"]/div[3]/div/div/div[1]/div/div/div[', i, ']') # licitaciones y contrataciones
xpath <- paste0("//*[@id='page_container']/div[3]/div[1]/div/div[1]/div/div/div[3]/div/div/div/div[", i, "]") # Licitaciones de obra pública
element <- page %>% html_node(xpath = xpath) %>% html_text(trim = TRUE)
if (!is.null(element)) {
cleaned_element <- clean_and_split(element)
all_elements[[length(all_elements) + 1]] <- cleaned_element
}
}
View(data_df)
View(all_elements)
c(seq(3,11,2),12,13,14, seq(16,92,2))
i <- 13
xpath <- paste0("//*[@id='page_container']/div[3]/div[1]/div/div[1]/div/div/div[3]/div/div/div/div[", i, "]") # Licitaciones de obra pública
xpath
# Initialize an empty list to store the elements
all_elements <- list()
rm(i)
# Loop over the range of XPaths
for (
# i in 4:290 # licitaciones y contrataciones
i in c(seq(3,11,2),12,13,14, seq(16,92,2)) # licitaciones de obra pública
) {
# xpath <- paste0('//*[@id="page_container"]/div[3]/div/div/div[1]/div/div/div[', i, ']') # licitaciones y contrataciones
xpath <- paste0("//*[@id='page_container']/div[3]/div[1]/div/div[1]/div/div/div[3]/div/div/div/div[", i, "]") # Licitaciones de obra pública
element <- page %>% html_node(xpath = xpath) %>% html_text(trim = TRUE)
if (!is.null(element)) {
cleaned_element <- clean_and_split(element)
all_elements[[length(all_elements) + 1]] <- cleaned_element
}
}
View(all_elements)
# Define the URL
url <- "https://ciudaddemendoza.gob.ar/licitaciones-de-obras-publicas/"
# Read the HTML page
webpage <- read_html(url)
# Extract all tables
tables <- webpage %>%
html_nodes("table") %>%
html_table(fill = TRUE)
# Display the tables
tables
webpage
# Define the URL
url <- "https://ciudaddemendoza.gob.ar/licitaciones-de-obras-publicas/"
# Perform the GET request
response <- GET(url)
# Parse the content of the response
content <- content(response, as = "text", encoding = "UTF-8")
# Parse the HTML content
webpage <- read_html(content)
# Extract the specific elements containing tables
table_containers <- html_nodes(webpage, ".vc_row.vpb_row.vc_inner.vc_row-fluid.vc_custom_1667565165902.vc_row-has-fill")
# Extract all tables within the specific elements and convert to data frames
tables <- table_containers %>%
html_nodes("table") %>%
html_table(fill = TRUE)
# Display the tables
tables
page <- read_html("https://ciudaddemendoza.gob.ar/licitaciones-de-obras-publicas/") # Licitaciones de obra pública
c(seq(3,11,2), seq(12,92,2))
# Function to clean and separate the text into 4 parts
clean_and_split <- function(text) {
# Replace multiple newlines and tabs with a single newline
text <- gsub("\n+", "\n", text)
text <- gsub("\t+", "", text)
# Split the text by newline
parts <- unlist(strsplit(text, "\n"))
# Trim whitespace and remove empty parts
parts <- trimws(parts)
parts <- parts[parts != ""]
return(parts)
}
# Initialize an empty list to store the elements
all_elements <- list()
rm(i)
# Loop over the range of XPaths
for (
# i in 4:290 # licitaciones y contrataciones
i in c(seq(3,11,2),12,13,14, seq(16,92,2)) # licitaciones de obra pública
) {
# xpath <- paste0('//*[@id="page_container"]/div[3]/div/div/div[1]/div/div/div[', i, ']') # licitaciones y contrataciones
xpath <- paste0("//*[@id='page_container']/div[3]/div[1]/div/div[1]/div/div/div[3]/div/div/div/div[", i, "]") # Licitaciones de obra pública
element <- page %>% html_node(xpath = xpath) %>% html_text(trim = TRUE)
if (!is.null(element)) {
cleaned_element <- clean_and_split(element)
all_elements[[length(all_elements) + 1]] <- cleaned_element
}
}
View(all_elements)
# Convert the list to a dataframe
data_df <- do.call(rbind, all_elements) %>% as.data.frame(stringsAsFactors = FALSE)
data_df <- data_df %>% dplyr::mutate(V5 = ifelse(V5 == V1, NA, V5),
V6 = ifelse(V6 == V1 | V6 == V2, NA, V6))
data_df
# Convert the list to a dataframe
data_df <- do.call(rbind, all_elements) %>% as.data.frame(stringsAsFactors = FALSE)
data_df
all_elements[[1]]
openxlsx::write.xlsx(data_df, file = paste0(getwd(), "/licitaciones_obrapublica_mza.xlsx"))
paste0(getwd(), "/licitaciones_obrapublica_mza.xlsx")
View(all_elements)
